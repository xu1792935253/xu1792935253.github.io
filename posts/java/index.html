<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PaperMod</title>
<meta name="keywords" content="" />
<meta name="description" content="Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。
Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://xu1792935253.github.io/hugo-PaperMod/posts/java/" />
<link crossorigin="anonymous" href="/hugo-PaperMod/assets/css/stylesheet.min.1c5241cc5c31e8a1af5a56caa332bfa60cee35277d8fb31c7063ca9ed7258093.css" integrity="sha256-HFJBzFwx6KGvWlbKozK/pgzuNSd9j7MccGPKntclgJM=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xu1792935253.github.io/hugo-PaperMod/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xu1792935253.github.io/hugo-PaperMod/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xu1792935253.github.io/hugo-PaperMod/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xu1792935253.github.io/hugo-PaperMod/apple-touch-icon.png">
<link rel="mask-icon" href="https://xu1792935253.github.io/hugo-PaperMod/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.108.0">
<link rel="alternate" hreflang="en" href="https://xu1792935253.github.io/hugo-PaperMod/posts/java/" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。
Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xu1792935253.github.io/hugo-PaperMod/posts/java/" /><meta property="og:image" content="https://xu1792935253.github.io/hugo-PaperMod/papermod-cover.png"/><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xu1792935253.github.io/hugo-PaperMod/papermod-cover.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。
Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xu1792935253.github.io/hugo-PaperMod/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://xu1792935253.github.io/hugo-PaperMod/posts/java/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。",
  "keywords": [
    
  ],
  "articleBody": "Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。\nSpring AOP ：提供了⾯向切⾯的编程实现。\nSpring JDBC : Java数据库连接。\nSpring JMS ： Java消息服务。\nSpring ORM : ⽤于⽀持Hibernate等ORM⼯具。\nSpring Web : 为创建Web应⽤程序提供⽀持。\nSpring Test : 提供了对 JUnit 和 TestNG 测试的⽀持\n2.@RestController vs @Controller Controller 返回⼀个⻚⾯\n单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 @RestController 返回JSON 或 XML 形式数据\n但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离） @Controller +@ResponseBody 返回JSON 或 XML 形式数据\n如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解） @ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。\nSpring IOC \u0026 AOP 谈谈自己对Spring IOC 和AOP的理解 IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来\nSpring IoC的初始化过程\nIoC源码阅读：https://javadoop.com/post/spring-ioc\nAOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：\n当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。 Spring bean Spring 中的 bean 的作⽤域有哪些?\nsingleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建⼀个新的 bean 实例。 request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 中的单例 bean 的线程安全问题了解吗？\n⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。 常⻅的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式） @Component 和 @Bean 的区别是什么？\n作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。 @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 下面这个例子通过@Component无法实现\n将⼀个类声明为Spring的 bean 的注解有哪些?\n我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现： @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯ Spring 中的 bean ⽣命周期?\n文章1：https://www.cnblogs.com/zrtqsk/p/3735273.html 文章2：https://blog.csdn.net/riemann_/article/details/118500805 Bean 容器找到配置⽂件中 Spring Bean 的定义。 Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。 如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。 如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。 与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法 如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。 如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。 当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法 Spring MVC 说说⾃⼰对于 Spring MVC 了解?\n谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代\nModel1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；\nModel2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。\nMVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。\nSpringMVC ⼯作原理了解吗？\n客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中⽤到了哪些设计模式？ 谈谈Spring中用到了哪些设计模式： 面试官:“谈谈Spring中都用到了那些设计模式?\"。\n⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 …… Spring 事务 Spring 管理事务的⽅式有⼏种？\n编程式事务，在代码中硬编码。 (不推荐使⽤) 声明式事务，在配置⽂件中配置（推荐使⽤） Spring 事务中的隔离级别有哪⼏种?\nTransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别 Spring 事务中哪⼏种事务传播⾏为?\n⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED @Transactional(rollbackFor = Exception.class)注解了解吗？\n我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。 关于 @Transactional 注解推荐阅读的⽂章： @Transactional 详解_微风–轻许–的博客-CSDN博客_@transactional\n1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。\nSpring AOP ：提供了⾯向切⾯的编程实现。\nSpring JDBC : Java数据库连接。\nSpring JMS ： Java消息服务。\nSpring ORM : ⽤于⽀持Hibernate等ORM⼯具。\nSpring Web : 为创建Web应⽤程序提供⽀持。\nSpring Test : 提供了对 JUnit 和 TestNG 测试的⽀持\n2.@RestController vs @Controller Controller 返回⼀个⻚⾯\n单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 @RestController 返回JSON 或 XML 形式数据\n但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离） @Controller +@ResponseBody 返回JSON 或 XML 形式数据\n如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解） @ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。\nSpring IOC \u0026 AOP 谈谈自己对Spring IOC 和AOP的理解 IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来\nSpring IoC的初始化过程\nIoC源码阅读：https://javadoop.com/post/spring-ioc\nAOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：\n当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。 Spring bean Spring 中的 bean 的作⽤域有哪些?\nsingleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建⼀个新的 bean 实例。 request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 中的单例 bean 的线程安全问题了解吗？\n⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。 常⻅的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式） @Component 和 @Bean 的区别是什么？\n作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。 @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 下面这个例子通过@Component无法实现\n将⼀个类声明为Spring的 bean 的注解有哪些?\n我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现： @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯ Spring 中的 bean ⽣命周期?\n文章1：https://www.cnblogs.com/zrtqsk/p/3735273.html 文章2：https://blog.csdn.net/riemann_/article/details/118500805 Bean 容器找到配置⽂件中 Spring Bean 的定义。 Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。 如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。 如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。 与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法 如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。 如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。 当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法 Spring MVC 说说⾃⼰对于 Spring MVC 了解?\n谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代\nModel1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；\nModel2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。\nMVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。\nSpringMVC ⼯作原理了解吗？\n客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中⽤到了哪些设计模式？ 谈谈Spring中用到了哪些设计模式： 面试官:“谈谈Spring中都用到了那些设计模式?\"。\n⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 …… Spring 事务 Spring 管理事务的⽅式有⼏种？\n编程式事务，在代码中硬编码。 (不推荐使⽤) 声明式事务，在配置⽂件中配置（推荐使⽤） Spring 事务中的隔离级别有哪⼏种?\nTransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别 Spring 事务中哪⼏种事务传播⾏为?\n⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED @Transactional(rollbackFor = Exception.class)注解了解吗？\n我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。 关于 @Transactional 注解推荐阅读的⽂章： @Transactional 详解_微风–轻许–的博客-CSDN博客_@transactional\n1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。\nSpring AOP ：提供了⾯向切⾯的编程实现。\nSpring JDBC : Java数据库连接。\nSpring JMS ： Java消息服务。\nSpring ORM : ⽤于⽀持Hibernate等ORM⼯具。\nSpring Web : 为创建Web应⽤程序提供⽀持。\nSpring Test : 提供了对 JUnit 和 TestNG 测试的⽀持\n2.@RestController vs @Controller Controller 返回⼀个⻚⾯\n单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 @RestController 返回JSON 或 XML 形式数据\n但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离） @Controller +@ResponseBody 返回JSON 或 XML 形式数据\n如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解） @ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。\nSpring IOC \u0026 AOP 谈谈自己对Spring IOC 和AOP的理解 IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来\nSpring IoC的初始化过程\nIoC源码阅读：https://javadoop.com/post/spring-ioc\nAOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：\n当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。 Spring bean Spring 中的 bean 的作⽤域有哪些?\nsingleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建⼀个新的 bean 实例。 request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 中的单例 bean 的线程安全问题了解吗？\n⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。 常⻅的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式） @Component 和 @Bean 的区别是什么？\n作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。 @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 下面这个例子通过@Component无法实现\n将⼀个类声明为Spring的 bean 的注解有哪些?\n我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现： @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯ Spring 中的 bean ⽣命周期?\n文章1：https://www.cnblogs.com/zrtqsk/p/3735273.html 文章2：https://blog.csdn.net/riemann_/article/details/118500805 Bean 容器找到配置⽂件中 Spring Bean 的定义。 Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。 如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。 如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。 与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法 如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。 如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。 当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法 Spring MVC 说说⾃⼰对于 Spring MVC 了解?\n谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代\nModel1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；\nModel2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。\nMVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。\nSpringMVC ⼯作原理了解吗？\n客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中⽤到了哪些设计模式？ 谈谈Spring中用到了哪些设计模式： 面试官:“谈谈Spring中都用到了那些设计模式?\"。\n⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 …… Spring 事务 Spring 管理事务的⽅式有⼏种？\n编程式事务，在代码中硬编码。 (不推荐使⽤) 声明式事务，在配置⽂件中配置（推荐使⽤） Spring 事务中的隔离级别有哪⼏种?\nTransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别 Spring 事务中哪⼏种事务传播⾏为?\n⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED @Transactional(rollbackFor = Exception.class)注解了解吗？\n我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。 关于 @Transactional 注解推荐阅读的⽂章： @Transactional 详解_微风–轻许–的博客-CSDN博客_@transactional\n",
  "wordCount" : "2179",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xu1792935253.github.io/hugo-PaperMod/posts/java/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xu1792935253.github.io/hugo-PaperMod/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xu1792935253.github.io/hugo-PaperMod/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://xu1792935253.github.io/hugo-PaperMod/fr/" title="French"
                            aria-label=":fr:">🇫🇷</a>
                    </li>
                    <li>
                        <a href="https://xu1792935253.github.io/hugo-PaperMod/fa/" title="Fa"
                            aria-label="Fa">Fa</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xu1792935253.github.io/hugo-PaperMod/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://xu1792935253.github.io/hugo-PaperMod/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://xu1792935253.github.io/hugo-PaperMod/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://discord.gg/ahpmTvhVmp" title="Discord">
                    <span>Discord</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://xu1792935253.github.io/hugo-PaperMod/">Home</a>&nbsp;»&nbsp;<a href="https://xu1792935253.github.io/hugo-PaperMod/posts/">Posts</a></div>
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">11 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/Java/index.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#spring%e9%9d%a2%e8%af%95%e9%a2%98" aria-label="Spring面试题">Spring面试题</a></li>
                <li>
                    <a href="#1%e4%bb%80%e4%b9%88%e6%98%afspring%e6%a1%86%e6%9e%b6" aria-label="1.什么是Spring框架？">1.什么是Spring框架？</a></li>
                <li>
                    <a href="#2restcontroller-vs-controller" aria-label="2.@RestController vs @Controller">2.@RestController vs @Controller</a></li>
                <li>
                    <a href="#spring-ioc--aop" aria-label="Spring IOC &amp;amp; AOP">Spring IOC &amp; AOP</a></li>
                <li>
                    <a href="#spring-bean" aria-label="Spring bean">Spring bean</a></li>
                <li>
                    <a href="#spring-mvc" aria-label="Spring MVC">Spring MVC</a></li>
                <li>
                    <a href="#spring-%e6%a1%86%e6%9e%b6%e4%b8%ad%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="Spring 框架中⽤到了哪些设计模式？">Spring 框架中⽤到了哪些设计模式？</a></li>
                <li>
                    <a href="#spring-%e4%ba%8b%e5%8a%a1" aria-label="Spring 事务">Spring 事务</a></li>
                <li>
                    <a href="#1%e4%bb%80%e4%b9%88%e6%98%afspring%e6%a1%86%e6%9e%b6-1" aria-label="1.什么是Spring框架？">1.什么是Spring框架？</a></li>
                <li>
                    <a href="#2restcontroller-vs-controller-1" aria-label="2.@RestController vs @Controller">2.@RestController vs @Controller</a></li>
                <li>
                    <a href="#spring-ioc--aop-1" aria-label="Spring IOC &amp;amp; AOP">Spring IOC &amp; AOP</a></li>
                <li>
                    <a href="#spring-bean-1" aria-label="Spring bean">Spring bean</a></li>
                <li>
                    <a href="#spring-mvc-1" aria-label="Spring MVC">Spring MVC</a></li>
                <li>
                    <a href="#spring-%e6%a1%86%e6%9e%b6%e4%b8%ad%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-1" aria-label="Spring 框架中⽤到了哪些设计模式？">Spring 框架中⽤到了哪些设计模式？</a></li>
                <li>
                    <a href="#spring-%e4%ba%8b%e5%8a%a1-1" aria-label="Spring 事务">Spring 事务</a></li>
                <li>
                    <a href="#1%e4%bb%80%e4%b9%88%e6%98%afspring%e6%a1%86%e6%9e%b6-2" aria-label="1.什么是Spring框架？">1.什么是Spring框架？</a></li>
                <li>
                    <a href="#2restcontroller-vs-controller-2" aria-label="2.@RestController vs @Controller">2.@RestController vs @Controller</a></li>
                <li>
                    <a href="#spring-ioc--aop-2" aria-label="Spring IOC &amp;amp; AOP">Spring IOC &amp; AOP</a></li>
                <li>
                    <a href="#spring-bean-2" aria-label="Spring bean">Spring bean</a></li>
                <li>
                    <a href="#spring-mvc-2" aria-label="Spring MVC">Spring MVC</a></li>
                <li>
                    <a href="#spring-%e6%a1%86%e6%9e%b6%e4%b8%ad%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f-2" aria-label="Spring 框架中⽤到了哪些设计模式？">Spring 框架中⽤到了哪些设计模式？</a></li>
                <li>
                    <a href="#spring-%e4%ba%8b%e5%8a%a1-2" aria-label="Spring 事务">Spring 事务</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="spring面试题">Spring面试题<a hidden class="anchor" aria-hidden="true" href="#spring面试题">#</a></h1>
<h1 id="1什么是spring框架">1.什么是Spring框架？<a hidden class="anchor" aria-hidden="true" href="#1什么是spring框架">#</a></h1>
<ul>
<li>我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。</li>
<li>Spring 官⽹列出的 Spring 的 6 个特征:
<ul>
<li>核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。</li>
<li>测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。</li>
<li>数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。</li>
<li>Web⽀持 : Spring MVC和Spring WebFlux Web框架。</li>
<li>集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。</li>
<li>语⾔ ： Kotlin， Groovy，动态语⾔</li>
</ul>
</li>
<li>列举一些重要的Spring模块
<ul>
<li>
<p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。</p>
</li>
<li>
<p>Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。</p>
</li>
<li>
<p>Spring AOP ：提供了⾯向切⾯的编程实现。</p>
</li>
<li>
<p>Spring JDBC : Java数据库连接。</p>
</li>
<li>
<p>Spring JMS ： Java消息服务。</p>
</li>
<li>
<p>Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。</p>
</li>
<li>
<p>Spring Web : 为创建Web应⽤程序提供⽀持。</p>
</li>
<li>
<p>Spring Test : 提供了对 JUnit 和 TestNG 测试的⽀持</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
</ul>
<h1 id="2restcontroller-vs-controller">2.@RestController vs @Controller<a hidden class="anchor" aria-hidden="true" href="#2restcontroller-vs-controller">#</a></h1>
<ul>
<li>
<p>Controller 返回⼀个⻚⾯</p>
<ul>
<li>单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况</li>
</ul>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%201.png" alt="Untitled"  />
</p>
</li>
<li>
<p>@RestController 返回JSON 或 XML 形式数据</p>
<ul>
<li>但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）</li>
</ul>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%202.png" alt="Untitled"  />
</p>
</li>
<li>
<p>@Controller +@ResponseBody 返回JSON 或 XML 形式数据</p>
<ul>
<li>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解）</li>
</ul>
</li>
<li>
<p>@ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%203.png" alt="Untitled"  />
</p>
</li>
</ul>
<h1 id="spring-ioc--aop">Spring IOC &amp; AOP<a hidden class="anchor" aria-hidden="true" href="#spring-ioc--aop">#</a></h1>
<ul>
<li>谈谈自己对Spring IOC 和AOP的理解
<ul>
<li>
<p>IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来</p>
</li>
<li>
<p>Spring IoC的初始化过程</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%204.png" alt="Untitled"  />
</p>
</li>
<li>
<p>IoC源码阅读：<a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
</li>
<li>
<p>AOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%205.png" alt="Untitled"  />
</p>
</li>
<li>
<p>当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。</p>
</li>
</ul>
</li>
<li>Spring AOP 和 AspectJ AOP 有什么区别？
<ul>
<li>Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。</li>
</ul>
</li>
</ul>
<h1 id="spring-bean">Spring bean<a hidden class="anchor" aria-hidden="true" href="#spring-bean">#</a></h1>
<ul>
<li>
<p>Spring 中的 bean 的作⽤域有哪些?</p>
<ul>
<li>singleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建⼀个新的 bean 实例。</li>
<li>request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
</li>
<li>
<p>Spring 中的单例 bean 的线程安全问题了解吗？</p>
<ul>
<li>⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。</li>
<li>常⻅的有两种解决办法：
<ul>
<li>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
</ol>
</li>
<li>
<ol start="2">
<li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Component 和 @Bean 的区别是什么？</p>
<ul>
<li>
<ol>
<li>作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。</li>
</ol>
</li>
<li>
<ol start="2">
<li>@Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。</li>
</ol>
</li>
<li>
<ol start="3">
<li>@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现</li>
</ol>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%206.png" alt="Untitled"  />
</p>
<p>下面这个例子通过@Component无法实现</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%207.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
<li>
<p>将⼀个类声明为Spring的 bean 的注解有哪些?</p>
<ul>
<li>我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：
<ul>
<li>@Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。</li>
<li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Spring 中的 bean ⽣命周期?</p>
<ul>
<li>文章1：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></li>
<li>文章2：<a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li>
<li>Bean 容器找到配置⽂件中 Spring Bean 的定义。</li>
<li>Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。</li>
<li>如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。</li>
<li>如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。</li>
<li>如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。</li>
<li>与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法</li>
<li>如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。</li>
<li>如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法</li>
</ul>
</li>
</ul>
<h1 id="spring-mvc">Spring MVC<a hidden class="anchor" aria-hidden="true" href="#spring-mvc">#</a></h1>
<ul>
<li>
<p>说说⾃⼰对于 Spring MVC 了解?</p>
<ul>
<li>
<p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代</p>
</li>
<li>
<p>Model1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；</p>
</li>
<li>
<p>Model2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。</p>
</li>
<li>
<p>MVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%208.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
<li>
<p>SpringMVC ⼯作原理了解吗？</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%209.png" alt="Untitled"  />
</p>
<ul>
<li>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li>
</ol>
</li>
<li>
<ol start="2">
<li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。</li>
</ol>
</li>
<li>
<ol start="3">
<li>解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li>
</ol>
</li>
<li>
<ol start="4">
<li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
</ol>
</li>
<li>
<ol start="5">
<li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。</li>
</ol>
</li>
<li>
<ol start="6">
<li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li>
</ol>
</li>
<li>
<ol start="7">
<li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。</li>
</ol>
</li>
<li>
<ol start="8">
<li>把 View 返回给请求者（浏览器）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="spring-框架中到了哪些设计模式">Spring 框架中⽤到了哪些设计模式？<a hidden class="anchor" aria-hidden="true" href="#spring-框架中到了哪些设计模式">#</a></h1>
<ul>
<li>谈谈Spring中用到了哪些设计模式：</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd">面试官:&ldquo;谈谈Spring中都用到了那些设计模式?&quot;。</a></p>
<ul>
<li>⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式 : Spring AOP 功能的实现。</li>
<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>
<li>包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</li>
<li>适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。</li>
<li>&hellip;&hellip;</li>
</ul>
<h1 id="spring-事务">Spring 事务<a hidden class="anchor" aria-hidden="true" href="#spring-事务">#</a></h1>
<ul>
<li>
<p>Spring 管理事务的⽅式有⼏种？</p>
<ul>
<li>
<ol>
<li>编程式事务，在代码中硬编码。 (不推荐使⽤)</li>
</ol>
</li>
<li>
<ol start="2">
<li>声明式事务，在配置⽂件中配置（推荐使⽤）</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Spring 事务中的隔离级别有哪⼏种?</p>
<ul>
<li>TransactionDefinition 接⼝中定义了五个表示隔离级别的常量：</li>
<li>TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别</li>
</ul>
</li>
<li>
<p>Spring 事务中哪⼏种事务传播⾏为?</p>
<ul>
<li>⽀持当前事务的情况：
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
</li>
<li>不⽀持当前事务的情况：
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li>其他情况：
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Transactional(rollbackFor = Exception.class)注解了解吗？</p>
<ul>
<li>我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。</li>
<li>关于 @Transactional 注解推荐阅读的⽂章：</li>
</ul>
<p><a href="https://blog.csdn.net/jiangyu1013/article/details/84397366?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167013559516800192293985%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=167013559516800192293985&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-84397366-null-null.142%5Ev67%5Ejs_top,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_control2&amp;utm_term=%40transactional&amp;spm=1018.2226.3001.4187">@Transactional 详解_微风&ndash;轻许&ndash;的博客-CSDN博客_@transactional</a></p>
</li>
</ul>
<h1 id="1什么是spring框架-1">1.什么是Spring框架？<a hidden class="anchor" aria-hidden="true" href="#1什么是spring框架-1">#</a></h1>
<ul>
<li>我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。</li>
<li>Spring 官⽹列出的 Spring 的 6 个特征:
<ul>
<li>核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。</li>
<li>测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。</li>
<li>数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。</li>
<li>Web⽀持 : Spring MVC和Spring WebFlux Web框架。</li>
<li>集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。</li>
<li>语⾔ ： Kotlin， Groovy，动态语⾔</li>
</ul>
</li>
<li>列举一些重要的Spring模块
<ul>
<li>
<p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。</p>
</li>
<li>
<p>Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。</p>
</li>
<li>
<p>Spring AOP ：提供了⾯向切⾯的编程实现。</p>
</li>
<li>
<p>Spring JDBC : Java数据库连接。</p>
</li>
<li>
<p>Spring JMS ： Java消息服务。</p>
</li>
<li>
<p>Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。</p>
</li>
<li>
<p>Spring Web : 为创建Web应⽤程序提供⽀持。</p>
</li>
<li>
<p>Spring Test : 提供了对 JUnit 和 TestNG 测试的⽀持</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
</ul>
<h1 id="2restcontroller-vs-controller-1">2.@RestController vs @Controller<a hidden class="anchor" aria-hidden="true" href="#2restcontroller-vs-controller-1">#</a></h1>
<ul>
<li>
<p>Controller 返回⼀个⻚⾯</p>
<ul>
<li>单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况</li>
</ul>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%201.png" alt="Untitled"  />
</p>
</li>
<li>
<p>@RestController 返回JSON 或 XML 形式数据</p>
<ul>
<li>但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）</li>
</ul>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%202.png" alt="Untitled"  />
</p>
</li>
<li>
<p>@Controller +@ResponseBody 返回JSON 或 XML 形式数据</p>
<ul>
<li>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解）</li>
</ul>
</li>
<li>
<p>@ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%203.png" alt="Untitled"  />
</p>
</li>
</ul>
<h1 id="spring-ioc--aop-1">Spring IOC &amp; AOP<a hidden class="anchor" aria-hidden="true" href="#spring-ioc--aop-1">#</a></h1>
<ul>
<li>谈谈自己对Spring IOC 和AOP的理解
<ul>
<li>
<p>IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来</p>
</li>
<li>
<p>Spring IoC的初始化过程</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%204.png" alt="Untitled"  />
</p>
</li>
<li>
<p>IoC源码阅读：<a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
</li>
<li>
<p>AOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%205.png" alt="Untitled"  />
</p>
</li>
<li>
<p>当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。</p>
</li>
</ul>
</li>
<li>Spring AOP 和 AspectJ AOP 有什么区别？
<ul>
<li>Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。</li>
</ul>
</li>
</ul>
<h1 id="spring-bean-1">Spring bean<a hidden class="anchor" aria-hidden="true" href="#spring-bean-1">#</a></h1>
<ul>
<li>
<p>Spring 中的 bean 的作⽤域有哪些?</p>
<ul>
<li>singleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建⼀个新的 bean 实例。</li>
<li>request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
</li>
<li>
<p>Spring 中的单例 bean 的线程安全问题了解吗？</p>
<ul>
<li>⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。</li>
<li>常⻅的有两种解决办法：
<ul>
<li>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
</ol>
</li>
<li>
<ol start="2">
<li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Component 和 @Bean 的区别是什么？</p>
<ul>
<li>
<ol>
<li>作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。</li>
</ol>
</li>
<li>
<ol start="2">
<li>@Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。</li>
</ol>
</li>
<li>
<ol start="3">
<li>@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现</li>
</ol>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%206.png" alt="Untitled"  />
</p>
<p>下面这个例子通过@Component无法实现</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%207.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
<li>
<p>将⼀个类声明为Spring的 bean 的注解有哪些?</p>
<ul>
<li>我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：
<ul>
<li>@Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。</li>
<li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Spring 中的 bean ⽣命周期?</p>
<ul>
<li>文章1：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></li>
<li>文章2：<a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li>
<li>Bean 容器找到配置⽂件中 Spring Bean 的定义。</li>
<li>Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。</li>
<li>如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。</li>
<li>如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。</li>
<li>如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。</li>
<li>与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法</li>
<li>如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。</li>
<li>如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法</li>
</ul>
</li>
</ul>
<h1 id="spring-mvc-1">Spring MVC<a hidden class="anchor" aria-hidden="true" href="#spring-mvc-1">#</a></h1>
<ul>
<li>
<p>说说⾃⼰对于 Spring MVC 了解?</p>
<ul>
<li>
<p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代</p>
</li>
<li>
<p>Model1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；</p>
</li>
<li>
<p>Model2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。</p>
</li>
<li>
<p>MVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%208.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
<li>
<p>SpringMVC ⼯作原理了解吗？</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%209.png" alt="Untitled"  />
</p>
<ul>
<li>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li>
</ol>
</li>
<li>
<ol start="2">
<li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。</li>
</ol>
</li>
<li>
<ol start="3">
<li>解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li>
</ol>
</li>
<li>
<ol start="4">
<li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
</ol>
</li>
<li>
<ol start="5">
<li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。</li>
</ol>
</li>
<li>
<ol start="6">
<li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li>
</ol>
</li>
<li>
<ol start="7">
<li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。</li>
</ol>
</li>
<li>
<ol start="8">
<li>把 View 返回给请求者（浏览器）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="spring-框架中到了哪些设计模式-1">Spring 框架中⽤到了哪些设计模式？<a hidden class="anchor" aria-hidden="true" href="#spring-框架中到了哪些设计模式-1">#</a></h1>
<ul>
<li>谈谈Spring中用到了哪些设计模式：</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd">面试官:&ldquo;谈谈Spring中都用到了那些设计模式?&quot;。</a></p>
<ul>
<li>⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式 : Spring AOP 功能的实现。</li>
<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>
<li>包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</li>
<li>适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。</li>
<li>&hellip;&hellip;</li>
</ul>
<h1 id="spring-事务-1">Spring 事务<a hidden class="anchor" aria-hidden="true" href="#spring-事务-1">#</a></h1>
<ul>
<li>
<p>Spring 管理事务的⽅式有⼏种？</p>
<ul>
<li>
<ol>
<li>编程式事务，在代码中硬编码。 (不推荐使⽤)</li>
</ol>
</li>
<li>
<ol start="2">
<li>声明式事务，在配置⽂件中配置（推荐使⽤）</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Spring 事务中的隔离级别有哪⼏种?</p>
<ul>
<li>TransactionDefinition 接⼝中定义了五个表示隔离级别的常量：</li>
<li>TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别</li>
</ul>
</li>
<li>
<p>Spring 事务中哪⼏种事务传播⾏为?</p>
<ul>
<li>⽀持当前事务的情况：
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
</li>
<li>不⽀持当前事务的情况：
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li>其他情况：
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Transactional(rollbackFor = Exception.class)注解了解吗？</p>
<ul>
<li>我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。</li>
<li>关于 @Transactional 注解推荐阅读的⽂章：</li>
</ul>
<p><a href="https://blog.csdn.net/jiangyu1013/article/details/84397366?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167013559516800192293985%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=167013559516800192293985&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-84397366-null-null.142%5Ev67%5Ejs_top,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_control2&amp;utm_term=%40transactional&amp;spm=1018.2226.3001.4187">@Transactional 详解_微风&ndash;轻许&ndash;的博客-CSDN博客_@transactional</a></p>
</li>
</ul>
<h1 id="1什么是spring框架-2">1.什么是Spring框架？<a hidden class="anchor" aria-hidden="true" href="#1什么是spring框架-2">#</a></h1>
<ul>
<li>我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。</li>
<li>Spring 官⽹列出的 Spring 的 6 个特征:
<ul>
<li>核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。</li>
<li>测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。</li>
<li>数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。</li>
<li>Web⽀持 : Spring MVC和Spring WebFlux Web框架。</li>
<li>集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。</li>
<li>语⾔ ： Kotlin， Groovy，动态语⾔</li>
</ul>
</li>
<li>列举一些重要的Spring模块
<ul>
<li>
<p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。</p>
</li>
<li>
<p>Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。</p>
</li>
<li>
<p>Spring AOP ：提供了⾯向切⾯的编程实现。</p>
</li>
<li>
<p>Spring JDBC : Java数据库连接。</p>
</li>
<li>
<p>Spring JMS ： Java消息服务。</p>
</li>
<li>
<p>Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。</p>
</li>
<li>
<p>Spring Web : 为创建Web应⽤程序提供⽀持。</p>
</li>
<li>
<p>Spring Test : 提供了对 JUnit 和 TestNG 测试的⽀持</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
</ul>
<h1 id="2restcontroller-vs-controller-2">2.@RestController vs @Controller<a hidden class="anchor" aria-hidden="true" href="#2restcontroller-vs-controller-2">#</a></h1>
<ul>
<li>
<p>Controller 返回⼀个⻚⾯</p>
<ul>
<li>单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况</li>
</ul>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%201.png" alt="Untitled"  />
</p>
</li>
<li>
<p>@RestController 返回JSON 或 XML 形式数据</p>
<ul>
<li>但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离）</li>
</ul>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%202.png" alt="Untitled"  />
</p>
</li>
<li>
<p>@Controller +@ResponseBody 返回JSON 或 XML 形式数据</p>
<ul>
<li>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解）</li>
</ul>
</li>
<li>
<p>@ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%203.png" alt="Untitled"  />
</p>
</li>
</ul>
<h1 id="spring-ioc--aop-2">Spring IOC &amp; AOP<a hidden class="anchor" aria-hidden="true" href="#spring-ioc--aop-2">#</a></h1>
<ul>
<li>谈谈自己对Spring IOC 和AOP的理解
<ul>
<li>
<p>IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来</p>
</li>
<li>
<p>Spring IoC的初始化过程</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%204.png" alt="Untitled"  />
</p>
</li>
<li>
<p>IoC源码阅读：<a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
</li>
<li>
<p>AOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%205.png" alt="Untitled"  />
</p>
</li>
<li>
<p>当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。</p>
</li>
</ul>
</li>
<li>Spring AOP 和 AspectJ AOP 有什么区别？
<ul>
<li>Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。</li>
</ul>
</li>
</ul>
<h1 id="spring-bean-2">Spring bean<a hidden class="anchor" aria-hidden="true" href="#spring-bean-2">#</a></h1>
<ul>
<li>
<p>Spring 中的 bean 的作⽤域有哪些?</p>
<ul>
<li>singleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建⼀个新的 bean 实例。</li>
<li>request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
</li>
<li>
<p>Spring 中的单例 bean 的线程安全问题了解吗？</p>
<ul>
<li>⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。</li>
<li>常⻅的有两种解决办法：
<ul>
<li>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
</ol>
</li>
<li>
<ol start="2">
<li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Component 和 @Bean 的区别是什么？</p>
<ul>
<li>
<ol>
<li>作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。</li>
</ol>
</li>
<li>
<ol start="2">
<li>@Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。</li>
</ol>
</li>
<li>
<ol start="3">
<li>@Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现</li>
</ol>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%206.png" alt="Untitled"  />
</p>
<p>下面这个例子通过@Component无法实现</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%207.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
<li>
<p>将⼀个类声明为Spring的 bean 的注解有哪些?</p>
<ul>
<li>我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：
<ul>
<li>@Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。</li>
<li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Spring 中的 bean ⽣命周期?</p>
<ul>
<li>文章1：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></li>
<li>文章2：<a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li>
<li>Bean 容器找到配置⽂件中 Spring Bean 的定义。</li>
<li>Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。</li>
<li>如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。</li>
<li>如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。</li>
<li>如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。</li>
<li>与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法</li>
<li>如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。</li>
<li>如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法</li>
</ul>
</li>
</ul>
<h1 id="spring-mvc-2">Spring MVC<a hidden class="anchor" aria-hidden="true" href="#spring-mvc-2">#</a></h1>
<ul>
<li>
<p>说说⾃⼰对于 Spring MVC 了解?</p>
<ul>
<li>
<p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代</p>
</li>
<li>
<p>Model1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；</p>
</li>
<li>
<p>Model2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。</p>
</li>
<li>
<p>MVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%208.png" alt="Untitled"  />
</p>
</li>
</ul>
</li>
<li>
<p>SpringMVC ⼯作原理了解吗？</p>
<p><img loading="lazy" src="Spring%E9%9D%A2%E8%AF%95%E9%A2%98%2007cc2c55d16f481a85585faffd94e8cc/Untitled%209.png" alt="Untitled"  />
</p>
<ul>
<li>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li>
</ol>
</li>
<li>
<ol start="2">
<li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。</li>
</ol>
</li>
<li>
<ol start="3">
<li>解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li>
</ol>
</li>
<li>
<ol start="4">
<li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
</ol>
</li>
<li>
<ol start="5">
<li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。</li>
</ol>
</li>
<li>
<ol start="6">
<li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li>
</ol>
</li>
<li>
<ol start="7">
<li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。</li>
</ol>
</li>
<li>
<ol start="8">
<li>把 View 返回给请求者（浏览器）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="spring-框架中到了哪些设计模式-2">Spring 框架中⽤到了哪些设计模式？<a hidden class="anchor" aria-hidden="true" href="#spring-框架中到了哪些设计模式-2">#</a></h1>
<ul>
<li>谈谈Spring中用到了哪些设计模式：</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd">面试官:&ldquo;谈谈Spring中都用到了那些设计模式?&quot;。</a></p>
<ul>
<li>⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。</li>
<li>代理设计模式 : Spring AOP 功能的实现。</li>
<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>
<li>包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li>观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</li>
<li>适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。</li>
<li>&hellip;&hellip;</li>
</ul>
<h1 id="spring-事务-2">Spring 事务<a hidden class="anchor" aria-hidden="true" href="#spring-事务-2">#</a></h1>
<ul>
<li>
<p>Spring 管理事务的⽅式有⼏种？</p>
<ul>
<li>
<ol>
<li>编程式事务，在代码中硬编码。 (不推荐使⽤)</li>
</ol>
</li>
<li>
<ol start="2">
<li>声明式事务，在配置⽂件中配置（推荐使⽤）</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Spring 事务中的隔离级别有哪⼏种?</p>
<ul>
<li>TransactionDefinition 接⼝中定义了五个表示隔离级别的常量：</li>
<li>TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别</li>
</ul>
</li>
<li>
<p>Spring 事务中哪⼏种事务传播⾏为?</p>
<ul>
<li>⽀持当前事务的情况：
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
</li>
<li>不⽀持当前事务的情况：
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li>其他情况：
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED</li>
</ul>
</li>
</ul>
</li>
<li>
<p>@Transactional(rollbackFor = Exception.class)注解了解吗？</p>
<ul>
<li>我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。</li>
<li>关于 @Transactional 注解推荐阅读的⽂章：</li>
</ul>
<p><a href="https://blog.csdn.net/jiangyu1013/article/details/84397366?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167013559516800192293985%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=167013559516800192293985&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-84397366-null-null.142%5Ev67%5Ejs_top,201%5Ev3%5Eadd_ask,213%5Ev2%5Et3_control2&amp;utm_term=%40transactional&amp;spm=1018.2226.3001.4187">@Transactional 详解_微风&ndash;轻许&ndash;的博客-CSDN博客_@transactional</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on twitter"
        href="https://twitter.com/intent/tweet/?text=&amp;url=https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f&amp;title=&amp;summary=&amp;source=https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f&title=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on whatsapp"
        href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share  on telegram"
        href="https://telegram.me/share/url?text=&amp;url=https%3a%2f%2fxu1792935253.github.io%2fhugo-PaperMod%2fposts%2fjava%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://xu1792935253.github.io/hugo-PaperMod/">PaperMod</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
