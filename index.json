[{"content":"Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。\nSpring AOP ：提供了⾯向切⾯的编程实现。\nSpring JDBC : Java数据库连接。\nSpring JMS ： Java消息服务。\nSpring ORM : ⽤于⽀持Hibernate等ORM⼯具。\nSpring Web : 为创建Web应⽤程序提供⽀持。\nSpring Test : 提供了对 JUnit 和 TestNG 测试的⽀持\n2.@RestController vs @Controller Controller 返回⼀个⻚⾯\n单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 @RestController 返回JSON 或 XML 形式数据\n但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离） @Controller +@ResponseBody 返回JSON 或 XML 形式数据\n如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解） @ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。\nSpring IOC \u0026amp; AOP 谈谈自己对Spring IOC 和AOP的理解 IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来\nSpring IoC的初始化过程\nIoC源码阅读：https://javadoop.com/post/spring-ioc\nAOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：\n当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。 Spring bean Spring 中的 bean 的作⽤域有哪些?\nsingleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建⼀个新的 bean 实例。 request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 中的单例 bean 的线程安全问题了解吗？\n⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。 常⻅的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式） @Component 和 @Bean 的区别是什么？\n作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。 @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 下面这个例子通过@Component无法实现\n将⼀个类声明为Spring的 bean 的注解有哪些?\n我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现： @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯ Spring 中的 bean ⽣命周期?\n文章1：https://www.cnblogs.com/zrtqsk/p/3735273.html 文章2：https://blog.csdn.net/riemann_/article/details/118500805 Bean 容器找到配置⽂件中 Spring Bean 的定义。 Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。 如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。 如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。 与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法 如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。 如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。 当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法 Spring MVC 说说⾃⼰对于 Spring MVC 了解?\n谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代\nModel1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；\nModel2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。\nMVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。\nSpringMVC ⼯作原理了解吗？\n客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中⽤到了哪些设计模式？ 谈谈Spring中用到了哪些设计模式： 面试官:\u0026ldquo;谈谈Spring中都用到了那些设计模式?\u0026quot;。\n⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 \u0026hellip;\u0026hellip; Spring 事务 Spring 管理事务的⽅式有⼏种？\n编程式事务，在代码中硬编码。 (不推荐使⽤) 声明式事务，在配置⽂件中配置（推荐使⽤） Spring 事务中的隔离级别有哪⼏种?\nTransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别 Spring 事务中哪⼏种事务传播⾏为?\n⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED @Transactional(rollbackFor = Exception.class)注解了解吗？\n我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。 关于 @Transactional 注解推荐阅读的⽂章： @Transactional 详解_微风\u0026ndash;轻许\u0026ndash;的博客-CSDN博客_@transactional\n1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。\nSpring AOP ：提供了⾯向切⾯的编程实现。\nSpring JDBC : Java数据库连接。\nSpring JMS ： Java消息服务。\nSpring ORM : ⽤于⽀持Hibernate等ORM⼯具。\nSpring Web : 为创建Web应⽤程序提供⽀持。\nSpring Test : 提供了对 JUnit 和 TestNG 测试的⽀持\n2.@RestController vs @Controller Controller 返回⼀个⻚⾯\n单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 @RestController 返回JSON 或 XML 形式数据\n但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离） @Controller +@ResponseBody 返回JSON 或 XML 形式数据\n如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解） @ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。\nSpring IOC \u0026amp; AOP 谈谈自己对Spring IOC 和AOP的理解 IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来\nSpring IoC的初始化过程\nIoC源码阅读：https://javadoop.com/post/spring-ioc\nAOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：\n当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。 Spring bean Spring 中的 bean 的作⽤域有哪些?\nsingleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建⼀个新的 bean 实例。 request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 中的单例 bean 的线程安全问题了解吗？\n⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。 常⻅的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式） @Component 和 @Bean 的区别是什么？\n作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。 @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 下面这个例子通过@Component无法实现\n将⼀个类声明为Spring的 bean 的注解有哪些?\n我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现： @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯ Spring 中的 bean ⽣命周期?\n文章1：https://www.cnblogs.com/zrtqsk/p/3735273.html 文章2：https://blog.csdn.net/riemann_/article/details/118500805 Bean 容器找到配置⽂件中 Spring Bean 的定义。 Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。 如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。 如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。 与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法 如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。 如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。 当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法 Spring MVC 说说⾃⼰对于 Spring MVC 了解?\n谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代\nModel1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；\nModel2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。\nMVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。\nSpringMVC ⼯作原理了解吗？\n客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中⽤到了哪些设计模式？ 谈谈Spring中用到了哪些设计模式： 面试官:\u0026ldquo;谈谈Spring中都用到了那些设计模式?\u0026quot;。\n⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 \u0026hellip;\u0026hellip; Spring 事务 Spring 管理事务的⽅式有⼏种？\n编程式事务，在代码中硬编码。 (不推荐使⽤) 声明式事务，在配置⽂件中配置（推荐使⽤） Spring 事务中的隔离级别有哪⼏种?\nTransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别 Spring 事务中哪⼏种事务传播⾏为?\n⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED @Transactional(rollbackFor = Exception.class)注解了解吗？\n我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。 关于 @Transactional 注解推荐阅读的⽂章： @Transactional 详解_微风\u0026ndash;轻许\u0026ndash;的博客-CSDN博客_@transactional\n1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。\nSpring AOP ：提供了⾯向切⾯的编程实现。\nSpring JDBC : Java数据库连接。\nSpring JMS ： Java消息服务。\nSpring ORM : ⽤于⽀持Hibernate等ORM⼯具。\nSpring Web : 为创建Web应⽤程序提供⽀持。\nSpring Test : 提供了对 JUnit 和 TestNG 测试的⽀持\n2.@RestController vs @Controller Controller 返回⼀个⻚⾯\n单独使⽤ @Controller 不加 @ResponseBody 的话⼀般使⽤在要返回⼀个视图的情况，这种情况属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 @RestController 返回JSON 或 XML 形式数据\n但 @RestController 只返回对象，对象数据直接以 JSON 或 XML 形式写⼊ HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是⽬前⽇常开发所接触的最常⽤的情况（前后端分离） @Controller +@ResponseBody 返回JSON 或 XML 形式数据\n如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使⽤ @Controller 并结合 @ResponseBody 注解，也就是说 @Controller + @ResponseBody = @RestController （Spring 4之后新加的注解） @ResponseBody 注解的作⽤是将 Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式之后，写⼊到HTTP 响应(Response)对象的 body 中，通常⽤来返回 JSON 或者XML 数据，返回 JSON 数据的情况⽐较多。\nSpring IOC \u0026amp; AOP 谈谈自己对Spring IOC 和AOP的理解 IoC：IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key， value） ,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流⾏起来\nSpring IoC的初始化过程\nIoC源码阅读：https://javadoop.com/post/spring-ioc\nAOP：AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关， 却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码， 降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤Cglib ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示：\n当然你也可以使⽤ AspectJ ,Spring AOP 已经集成了AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。使⽤ AOP 之后我们可以把⼀些通⽤功能抽象出来，在需要⽤到的地⽅直接使⽤即可，这样⼤⼤简化了代码量。我们需要增加新功能时也⽅便，这样也提⾼了系统扩展性。⽇志功能、事务管理等等场景都⽤到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽ AspectJ 基于字节码操作(Bytecode Manipulation)。Spring AOP 已经集成了 AspectJ ， AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。 AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。 Spring bean Spring 中的 bean 的作⽤域有哪些?\nsingleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建⼀个新的 bean 实例。 request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。 session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义， Spring5已经没有了。 Portlet是能够⽣成语义代码(例如： HTML)⽚段的⼩型Java Web插件。它们基于portlet容器，可以像servlet⼀样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring 中的单例 bean 的线程安全问题了解吗？\n⼤部分时候我们并没有在系统中使⽤多线程，所以很少有⼈会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。 常⻅的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式） @Component 和 @Bean 的区别是什么？\n作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。 @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还我。 @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 下面这个例子通过@Component无法实现\n将⼀个类声明为Spring的 bean 的注解有哪些?\n我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现： @Component ：通⽤的注解，可标注任意类为 Spring 组件。如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 @Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯ Spring 中的 bean ⽣命周期?\n文章1：https://www.cnblogs.com/zrtqsk/p/3735273.html 文章2：https://blog.csdn.net/riemann_/article/details/118500805 Bean 容器找到配置⽂件中 Spring Bean 的定义。 Bean 容器利⽤ Java Reflection API 创建⼀个Bean的实例。 如果涉及到⼀些属性值 利⽤ set() ⽅法设置⼀些属性值。 如果 Bean 实现了 BeanNameAware 接⼝，调⽤ setBeanName() ⽅法，传⼊Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接⼝，调⽤ setBeanClassLoader() ⽅法，传⼊ClassLoader 对象的实例。 与上⾯的类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessBeforeInitialization() ⽅法 如果Bean实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。 如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执⾏ postProcessAfterInitialization() ⽅法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接⼝，执⾏ destroy() ⽅法。 当要销毁 Bean 的时候，如果 Bean 在配置⽂件中的定义包含 destroy-method 属性，执⾏指定的⽅法 Spring MVC 说说⾃⼰对于 Spring MVC 了解?\n谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代\nModel1 时代 : 很多学 Java 后端⽐较晚的朋友可能并没有接触过 Model1 模式下的JavaWeb 应⽤开发。在 Model1 模式下，整个 Web 应⽤⼏乎全部⽤ JSP ⻚⾯组成，只⽤少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层⼜是表现层。显⽽易⻅，这种模式存在很多问题。⽐如①将控制逻辑和表现逻辑混杂在⼀起，导致代码重⽤率极低；②前端和后端相互依赖，难以进⾏测试并且开发效率极低；\nModel2 时代 ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+JSP（View,） +Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。 Model:系统涉及的数据，也就是 dao 和 bean。 View：展示模型中的数据，只是⽤来展示。 Controller：处理⽤户请求都发送给 ，返回数据给 JSP 并展示给⽤户。Model2 模式下还存在很多问题， Model2的抽象和封装程度还远远不够，使⽤Model2进⾏开发时不可避免地会重复造轮⼦，这就⼤⼤降低了程序的可维护性和复⽤性。于是很多JavaWeb开发相关的 MVC 框架应运⽽⽣⽐如Struts2，但是 Struts2 ⽐较笨重。随着 Spring 轻量级开发框架的流⾏， Spring ⽣态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相⽐于Struts2 ， Spring MVC 使⽤更加简单和⽅便，开发效率更⾼，并且 Spring MVC 运⾏速度更快。\nMVC 是⼀种设计模式,Spring MVC 是⼀款很优秀的 MVC 框架。 Spring MVC 可以帮助我们进⾏更简洁的Web层的开发，并且它天⽣与 Spring 框架集成。 Spring MVC 下我们⼀般把后端项⽬分为 Service层（处理业务）、 Dao层（数据库操作）、 Entity层（实体类）、 Controller层(控制层，返回数据给前台⻚⾯)。\nSpringMVC ⼯作原理了解吗？\n客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。 DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。 解析到对应的 Handler （也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象， View 是个逻辑上的 View 。 ViewResolver 会根据逻辑 View 查找实际的 View 。 DispaterServlet 把返回的 Model 传给 View （视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中⽤到了哪些设计模式？ 谈谈Spring中用到了哪些设计模式： 面试官:\u0026ldquo;谈谈Spring中都用到了那些设计模式?\u0026quot;。\n⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。 适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 \u0026hellip;\u0026hellip; Spring 事务 Spring 管理事务的⽅式有⼏种？\n编程式事务，在代码中硬编码。 (不推荐使⽤) 声明式事务，在配置⽂件中配置（推荐使⽤） Spring 事务中的隔离级别有哪⼏种?\nTransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT: 使⽤后端数据库默认的隔离级别， Mysql默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别 Spring 事务中哪⼏种事务传播⾏为?\n⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务 TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。 TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED @Transactional(rollbackFor = Exception.class)注解了解吗？\n我们知道： Exception分为运⾏时异常RuntimeException和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。 关于 @Transactional 注解推荐阅读的⽂章： @Transactional 详解_微风\u0026ndash;轻许\u0026ndash;的博客-CSDN博客_@transactional\n","permalink":"https://xu1792935253.github.io/hugo-PaperMod/posts/java/","summary":"Spring面试题 1.什么是Spring框架？ 我们⼀般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使⽤这些模块可以很⽅便地协助我们进⾏开发。这些模块是：核⼼容器、数据访问/集成,、 Web、 AOP（⾯向切⾯编程）、⼯具、消息和测试模块。⽐如： Core Container 中的 Core 组件是Spring 所有组件的核⼼， Beans 组件和 Context 组件是实现IOC和依赖注⼊的基础， AOP组件⽤来实现⾯向切⾯编程。 Spring 官⽹列出的 Spring 的 6 个特征: 核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， i18n，验证，数据绑定，类型转换， SpEL。 测试 ：模拟对象， TestContext框架， Spring MVC 测试， WebTestClient。 数据访问 ：事务， DAO⽀持， JDBC， ORM，编组XML。 Web⽀持 : Spring MVC和Spring WebFlux Web框架。 集成 ：远程处理， JMS， JCA， JMX，电⼦邮件，任务，调度，缓存。 语⾔ ： Kotlin， Groovy，动态语⾔ 列举一些重要的Spring模块 Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。\nSpring Aspects ： 该模块为与AspectJ的集成提供⽀持。","title":""}]